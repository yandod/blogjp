---
layout: post
status: publish
published: true
title: Unicorn についての知りたい情報のすべて (翻訳版)
author: tylerbird
author_login: tylerbird
author_email: tylerbird@engineyard.com
wordpress_id: 359
wordpress_url: http://www.engineyard.co.jp/blog/?p=359
date: 2013-01-17 04:57:10.000000000 +09:00
categories:
- Uncategorized
tags: []
comments: []
---
<div class="note">
本記事は<a href="http://www.engineyard.com/blog/2010/everything-you-need-to-know-about-unicorn/" target="_blank">英語版ブログで2010年5月18日に公開された記事</a>の翻訳版です。
</div>
Engine Yard のお客様や開発者の友人の多くが Unicorn を愛用し、推奨しているので、これについて兼ねてから勉強したいと思ってました。そんな矢先に、幸いにもその学習機会が自然と訪れました。最初は無料のリソースをいろいろと見ながら疑問を解決しようとしましたが、思ったより難しく、結局は大元のソースに当たることにしました。

まず、十分な時間をかけて Unicorn の <a href="http://unicorn.bogomips.org/">README</a> ファイルを熟読しました。このファイルには総合情報が網羅されていますが、読み終えた後でも疑問が解決しなかったので、すべてまとめて Unicorn の開発チームに E メールで送ってみました。有難いことに、返信には私の全質問に対する答えが詳しく書かれていました。そのおかげで内情に通じることができたので、<em></em>この素晴らしいリソースを皆さんと共有しようと思った次第です。当社の<em>風変わりな</em>スタイルのブログ記事ではありませんが、有用な情報であることは確かです。なるべくわかりやすい形で説明したいと思います。

質問はトピックごとのセクションに整理されています。扱うトピックは、クライアント、デバッグ、プロセス管理、負荷分散、スレッドセーフ、Rack のサポートと Rack ラッパー、ログ ファイル、バイナリ アップグレード、分岐、リッスン インターフェイス、設定、非同期転送、バイナリ、依存関係です。たくさんのトピックがありますので、通読されてもいいでしょうし、関心のあるセクションにスキップしても構いません。
<h2>クライアント</h2>
<h3>"ファスト クライアント" とは?</h3>
サーバーで利用可能なネットワーク帯域幅を、完全に (またはほぼ完全に) 使用できるクライアント。通常 1 つの LAN (または同じホスト) 上のクライアントは、低速リンクを経由してサーバーにデータを少しずつ送信する必要がないため、これに該当します。
<h3>それに対して、スロー クライアントとは?</h3>
遅延の多い、または帯域幅が限られるクライアント。そのためサーバーがアイドル状態になり、要求のデータや応答のバッファ領域を待つことになります。FreeBSD の Accept Filter や Linux の deferred accept (遅延アクセプト) は、有効なスロー クライアントにおいてこの問題を軽減しますが、専用の攻撃はこうした機能でも回避できます。

Slowloris は、スロー クライアントが原因で起こり得る被害としておそらく一番有名なケースと思われます。しかし、それに類似したツールはほかにも昔からプライベートに存在しており、Unicorn の作者が開発した "David" ツールもその一例です。David ツールは、<a href="http://mid.gmane.org/20091008000942.GA25054@dcvr.yhbt.net">Slowloris</a> の後で David さん本人が一般に公開しました。
<blockquote>アイドルな キープアライブ接続を保ち続けるクライアントも、Unicorn (および従来の Apache prefork) のようなシンプルなサーバーにとって大きな問題となるので、Unicorn では keepalive がサポートされません。

Unicorn の作者は Rainbows! サーバーも手がけています。このサーバーは、スロー クライアントおよび待ち時間の長いアプリケーション (Comet/WebSockets) との直接通信を、nginx のフロントエンドなしで扱うために設計されています。</blockquote>
<h3>"待ち時間の長い高帯域幅接続" とは?</h3>
localhost またはローカル エリア ネットワーク上にあり、サーバーをアイドル状態にして他の要求に応えられなくすることのないすべての接続。
<h2>デバッグ</h2>
<h3>デバッグを行う方法の例を教えてください。</h3>
デバッグには再現性が不可欠です。プロセス状態は常に各要求ベースで明確に定義されていて、OS によって他の要求から可能な限り分離されているので、プロセスは本質的にシンプルです。たとえば次に述べるのは、特定クラスの要求に関連するメモリ リークを追跡する例です。

非 Ruby ユーザーの管理者が、ワーカーの一部が他のワーカーよりずっと大量のメモリを使用していることに気付きました。ログ ファイルの形式では常に各要求に応える PID が記録されるので、(コードを確認せずに) メモリ リークが発生しやすいエンドポイントを素早く絞り込むことができました。

同じプロセス内で要求がすべて処理されるサーバーでは、どのエンドポイントがメモリを消耗しているかを特定するのはずっと難しかったはずです。単一のプロセスが複数のクライアントを同時に扱うサーバーの場合、ソース コードを徹底的に調査して、メモリ リークの原因となった要求を追跡することが<em>必須</em>となります。
<h2>プロセス管理</h2>
<blockquote>「Unicorn は壊れたアプリケーションが原因で機能停止したワーカーを取り込み、再起動します。複数のプロセスやポートを自分で管理する必要はありません。Unicorn は、バックエンドに合わせて選択した任意数のワーカー プロセスを作成し、管理します。」</blockquote>
<h3>すると Unicorn には monit や god が必要ないということですか?</h3>
monit や god を絶対に<em>必要とする</em>サーバーは存在しません。これは管理者の安心感、アプリケーション、およびサポート要件によって決まります。マスター プロセスが機能停止するということも、稀ですがあり得ます。monit や god も機能停止の心配がないわけではありません。開発者はこれらのツールや Bluepill などの類似ツールを Unicorn と一緒に使用します。
<h2>負荷分散</h2>
<blockquote>「負荷分散はすべてオペレーティング システムのカーネルによって処理されます。ビジーなワーカー プロセスの背後に要求が集積することはありません。」</blockquote>
<h3>ということは、Mongrel キューの問題はないのでしょうか?</h3>
はい、1 台のマシンで Mongrel キューの問題が発生することはありません。ワーカー プロセスが単一のキューを共有し、ワーカーは処理を行える状態になった時点で初めてキューを離れます。ロード バランサーの背後のクラスターでキューの問題が起きる可能性はありますが、大半のサーバーがマルチコアで複数のワーカー プロセスを実行するため、リスクは軽減されます。キューは、<code>:listen</code> パラメーターを指定することでも調整できます。
<h2>スレッドセーフ</h2>
<h3>スレッドセーフが望ましい理由は?</h3>
スレッドセーフの有用性は状況の詳細に大きく左右されます。アプリケーションで実行できる対象の柔軟性がぐっと高まり、また理想的な状況においてはスレッドはメモリ効率がよく、比較的低コストです。したがって、アプリケーションをスレッド対応にすれば、熟練プログラマーにとってはプラスとなります。

しかしその一方で、既定でスレッドセーフにしてしまうと、シングルスレッドの環境でパフォーマンスが低下する可能性があります。競合なしのロックでも、メモリ バリアのために相当量のオーバーヘッドを追加することがあります。MRI と Python 両方のコア開発者は、これと同じ結論に達しています。
<h2>Rack のサポートと Rack ラッパー</h2>
<h3>どの Rack アプリケーションがサポートされますか?</h3>
Rack::Lint に合格するものならほとんどサポートされます (合格しなくてもサポートされる場合もあります)。
<h3>どのバージョンの Ruby on Rails をラッパーはサポートしますか?</h3>
manpage には 1.2.x から 2.3.x の全バージョンと記載されており、各バージョンの統合テストがあります。
<h2>ログ ファイル</h2>
<blockquote>「USR1 シグナルによりアプリケーション内の全ログ ファイルを再度開く組み込み機能です。これにより logrotate は、競合条件が発生しやすく低速な copytruncate メソッドの代わりに、rename を使ってファイルをアトミックかつ迅速に回転できるようになります。」</blockquote>
<h3>USR1 シグナルとは?</h3>
USR1 は最初のユーザー定義シグナルで、通常は、アプリケーションがその信号ハンドラーで何をするか決定する際に最高の柔軟性を提供します。USR1 シグナルを Unicorn に送信するには、次のように標準の <code>kill(1)</code> コマンドを使用します。
<pre escaped="true">kill -USR1 $PROCESS_ID
</pre>
nginx でも、ログ ファイルを再度開くために USR1 シグナルを使用します。Unicorn が受信するシグナルの大半は、学習しやすいよう nginx のシグナルにマッピングされます。また Unicorn は、単一の要求からの複数行のログ エントリが必ず同じファイルに出力されるよう措置を講じします。
<h2>バイナリ アップグレード</h2>
<h3>バイナリ アップグレードとは?</h3>
バイナリ アップグレードとは、Unicorn 自体、Ruby のバージョン、またはシステム C ライブラリを含む任意のシステム ライブラリをアップグレードすることです。コピーオンライト機能に依存するユーザーにとっては、これがアプリケーションをアップグレードする唯一の方法でもあります。
<h3>アップグレードを行う方法は?</h3>
アップグレード手順は nginx の場合と同じで、<a href="http://unicorn.bogomips.org/SIGNALS.html">こちら</a>にも記載されています (ページ下部)。
<h3>アップグレードを行うとどうなりますか?</h3>
古いプロセスを SIGQUIT で正常に終了したら、その同じコードでアプリケーションが正常に動作することを確認する必要があります。アプリケーションが破損している場合、もう一度「アップグレード」を行う必要がありますが、その際、場合によっては正常に機能することがわかっているバージョンに切り替える必要があります。
<h2>分岐</h2>
<h3><code>preload_app</code> ディレクティブとは?</h3>
<code>preload_app</code> ディレクティブは、ワーカーの分岐を行う前にアプリケーションを読み込んで、読み込まれたデータ構造を共有できるようにします。既定では、既存のサーバーとの互換性を追加設定なしで確保できるよう、各ワーカーがアプリケーションのプライベート コピーを読み込みます。
<h3><code>preload_app</code> ディレクティブを使用する事例にはどんなものがありますか?</h3>
<code>preload_app</code> を使用すると起動時間を大幅に短縮できます。Ruby Enterprise Edition (REE) を使用している場合、複数のプロセス間でメモリを共有するのも容易になります。また、REE では Linux など一部のプラットフォームで汎用の <code>malloc</code> ではなく <code>tcmalloc</code> を使用するので、コピーオンライトとは別個に、ほとんどのサーバー ワークロードのパフォーマンスが改善されます。
<h2>リッスン インターフェイス</h2>
<h3>アプリケーションのデバッグに利用できるよう、どうセットアップして使用すればよいかがわかる設定例を教えてください。</h3>
ワーカーが特定のアドレスでリッスンするようにセットアップして、そのアドレスをヒットする間ワーカーの <code>strace</code> などを実行し、様子を見ることができます。<a href="http://unicorn.bogomips.org/examples/unicorn.conf.rb">ここ</a>にコメントアウトされた例があります。次に示すのは、この例を短くしてコメントを解除したものです。
<pre lang="ruby" escaped="true">after_fork do |server, worker|
  # per-process listener ports for debugging/admin/migrations
  addr = "127.0.0.1:#{9293 + worker.nr}"
  server.listen(addr, :tries =&gt; -1, :delay =&gt; 5)
end
</pre>
通常は <code>strace</code> によってプロセスが遅延された結果、接続の <code>accept()</code> を試行しても他のワーカーとの競争に負け、要求を受け入れることはありません。
<h2>設定</h2>
<h3>初心者の参考になるような設定例はありますか?</h3>
<a href="http://unicorn.bogomips.org/examples/unicorn.conf.rb">ここ</a>にある例では、コメントも含めて多くの設定がカバーされています。一番シンプルなのは <code>preload_app=false</code> を使用するケースです。次に短い例を示します。
<pre lang="ruby" escaped="true">worker_processes 16
pid "/path/to/app/shared/pids/unicorn.pid"
stderr_path "/path/to/app/shared/log/unicorn.stderr.log"
stdout_path "/path/to/app/shared/log/unicorn.stdout.log"
</pre>
これに対し <code>preload_app=true</code> では、データベースやその他の接続の切断と再接続を行って意図しないリソース共有を回避する必要があるため、ずっと複雑な設定となる可能性があります。すべての設定内容は <code>Unicorn::Configurator</code> クラスの <a href="http://unicorn.bogomips.org/Unicorn/Configurator.html">RDoc</a> に記載されています。

<code>Unicorn::Configurator</code> の設定に加えて、基盤のサーバーとは関係なくすべての Rack アプリケーションで使用される、rackup 設定ファイル (通常は config.ru) もあります。さらに、システム/カーネルの調整も関係してきます。これについては Unicorn ドキュメントの<a href="http://unicorn.bogomips.org/TUNING.html">このセクション</a>で説明されています。
<h2>バイナリ</h2>
<h3><code>unicorn</code> 実行可能ファイルとは何ですか?また、<code>unicorn_rails</code> 実行可能ファイルとは何ですか?</h3>
<code>unicorn</code> 実行可能ファイルは Rack の "rackup" を基にした Rack 専用のツールで、Rack アプリケーション用に推奨されます。<code>unicorn_rails</code> は、Rack 以前のバージョンの Rails のユーザーが容易に Rack に移行できるよう作成されたものです。manpage では、これに代わり標準の <code>unicorn</code> を使用するよう Rails 3 ユーザーに推奨しています。
<h3>どのような違いがありますか?</h3>
<code>unicorn_rails</code> manpage によると、<code>unicorn_rails</code> の規則の一部は Rails の <code>script/server</code> を基にしています。"tmp" の下に <code>script/server</code> のようなディレクトリを作成し、-E/--environment スイッチが <code>RACK_ENV</code> の代わりに <code>RAILS_ENV</code> を設定します。
<h2>依存関係</h2>
<h3>Gem やシステム パッケージなどの依存関係はありますか?</h3>
現在 Unicorn が依存している Gem は Rack のみです。Unicorn は、Rack のどのリリース バージョンに対してもハードの依存関係を持ちません。Unicorn は、Unix 系のプラットフォームでは MRI 1.8 または 1.9 に依存します。C/Ragel HTTP パーサーを Rubinius 対応にする<a href="http://comments.gmane.org/gmane.comp.lang.ruby.unicorn.general/21">コミットは存在します</a>が、<a href="http://comments.gmane.org/gmane.comp.lang.ruby.rubinius.devel/398">ピュア Ruby コードで他の問題</a>がいくつか発生しています。git からの構築には Ragel が必要です (ただし配布されたソースの tarball/gems では必要ありません)。プロジェクトではコンパイルされていないバイナリは配布しません。

Unicorn は大部分のドキュメントに RDoc を使用し、Markdown manpage には John MacFarlane 氏の Pandoc (Haskell ツール) を使用しています。manpage が作成された時点では Ryan Tomayko 氏の ronn がまだリリースされていなかったので、当時 Markdown から manpage への変換ツールとしては Pandoc が最も一般的でした。
<h3>オペレーティング システム、RAM などの要件は?</h3>
POSIX 系の大半のプラットフォームがサポートされます。Unicorn は、<code>fork()</code>、ファイル記述子を子と共有する機能、シグナル、パイプ、リンクのないオープン ファイルなど、一連の Unix 的要素に依存します。

Unicorn はさまざまな Linux ディストリビューションにデプロイされており、十分にテスト済みです。Unicorn メーリング リストには OpenBSD 互換のためのレポートとパッチも寄せられているので、これも機能するはずです。Unicorn は、MRI によりネイティブで提供されてないエキゾチックなシステム呼び出しには依存していません。

RAM の使用量はアプリケーションやライブラリ、Ruby のバージョン、アーキテクチャのワード サイズ、および設定されたワーカー プロセス数に大きく依存します。使用量は他の Ruby ウェブ サーバーとあまり変わらないはずです。
<h2>まとめ</h2>
上記のような調べ物を始めたのは、何か特定の問題があったからというより、自分の頭の中のナレッジ ベースに穴があるのを感じたからです。その穴を埋めてみて、今あらためて Unicorn のロバストな機能に感心しています。<em>すべての</em>用途に最適なツールではないかも知れませんが、多くのケースで素晴らしい効果が得られることは確実です。いつもどおり、ご質問やコメントがありましたら、こちらに記してください。
